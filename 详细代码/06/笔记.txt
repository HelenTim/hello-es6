解构赋值：


      1.左右两边结构必须一样
      2.右边必须是个东西(等号右边的值，要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口)
      3.声明和赋值不能分开(必须在一句话里完成)



      let [a,b,c]=[12,5,8];
      let {a,b,c}={a: 12, b: 5, c: 8};

      4.数组不完全结构：等号左边的变量个数   不等于   等号右边数据的个数
           变量要么等于 undefined   要么等于   ([])  空数组
      5.解构赋值允许指定默认值：
          只有当一个数组成员严格等于undefined，默认值才会生效；
          如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值：
           function f() {
              console.log('aaa');
            }
          let [x = f()] = [1];  //此时x等于1。   进而 f()  就不会被执行；
      6.set数据结构 的结构    等号的左边  使用  数组 
      
      
  对象的结构赋值：变量必须与属性同名，才能取到正确的值（结构时的位置可以不对应）
        1.如果结构失败：那么值为undefined
        2.如果变量名与属性名不一致：属性名（他是对象结构时的 模式 不是变量 不保存值 ）和变量名（他保存值）都要写出来，此时变量名保存的就是变量值：
            这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）：
                let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
            也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者：
                let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
                // baz // "aaa"
                // foo // error: foo is not defined
        3.模式可以 被匹配多次：
                let obj = {
                      p: [
                        'Hello',
                        { y: 'World' }
                      ]
                };

                let { p, p: [x, { y }] } = obj;  // 此时    模式p   被匹配   两次
                x // "Hello"
                y // "World"
                p // ["Hello", {y: "World"}]
          4.注意，对象的解构赋值可以取到继承的属性。
          
          
      对象的解构也可以指定默认值：
      
      
      
      

