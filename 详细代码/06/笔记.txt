解构赋值：


      1.左右两边结构必须一样
      2.右边必须是个东西(等号右边的值，要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口)
      3.声明和赋值不能分开(必须在一句话里完成)
      4.解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。


      let [a,b,c]=[12,5,8];
      let {a,b,c}={a: 12, b: 5, c: 8};

      4.数组不完全结构：等号左边的变量个数   不等于   等号右边数据的个数
           变量要么等于 undefined   要么等于   ([])  空数组
      5.解构赋值允许指定默认值：
          只有当一个数组成员严格等于undefined，默认值才会生效；
          如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值：
           function f() {
              console.log('aaa');
            }
          let [x = f()] = [1];  //此时x等于1。   进而 f()  就不会被执行；
      6.set数据结构 的结构    等号的左边  使用  数组 
      
      
  对象的结构赋值：变量必须与属性同名，才能取到正确的值（结构时的位置可以不对应）
        1.如果结构失败：那么值为undefined
        2.如果变量名与属性名不一致：属性名（他是对象结构时的 模式 不是变量 不保存值 ）和变量名（他保存值）都要写出来，此时变量名保存的就是变量值：
            这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）：
                let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
            也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者：
                let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
                // baz // "aaa"
                // foo // error: foo is not defined    foo只是匹配的模式  而不是   变量
        3.模式可以 被匹配多次：
                let obj = {
                      p: [
                        'Hello',
                        { y: 'World' }
                      ]
                };

                let { p, p: [x, { y }] } = obj;  // 此时    模式p   被匹配   两次
                x // "Hello"
                y // "World"
                p // ["Hello", {y: "World"}]
          4.注意，对象的解构赋值可以取到继承的属性。
          
          
      对象的解构也可以指定默认值：默认值生效的条件是，对象的属性值严格等于undefined
              var {x, y = 5} = {x: 1};
                  x // 1
                  y // 5
              由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
              解构赋值允许等号左边的模式之中，不放置任何变量名。
              
   变量先声明后赋值时的解构：
            对于数组，不会报错：
                  var a, b;
                  [a, b] = [1, 2];
                  console.log(a); // 1
                  console.log(b); // 2
            但是对于对象来说就会报错：
                  let x;
                  {x} = {x: 1};// SyntaxError: syntax error
                  
                  解决办法：
                        let x;
                        ({x} = {x: 1});    //具体原因，参考：https://developer.mozilla.org/zh-                                             CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
   字符串解构：
         1.字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。
         2.类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。
   数值和布尔值的解构赋值:
         1.解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。
   函数参数的解构赋值：自注，下面的我们可以这样理解，函数在调用时一旦有实参那么就会替代定义函数时  等号右边的东西
         1.为函数move的参数指定默认值，而不是为变量x和y指定默认值
                 function move({x, y} = { x: 0, y: 0 }) {
                        return [x, y];
                  }

                  move({x: 3, y: 8}); // [3, 8]
                  move({x: 3}); // [3, undefined]
                  move({}); // [undefined, undefined]
                  move(); // [0, 0]
        2.不为函数move的参数指定默认值，而为变量x和y指定默认值
                  function move({x = 0, y = 0} = {}) {
                         return [x, y];
                  }

                  move({x: 3, y: 8}); // [3, 8]
                  move({x: 3}); // [3, 0]
                  move({}); // [0, 0]
                  move(); // [0, 0]
   
   解构时，我们特别注意圆括号问题：ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。
            自注：解构时  模式部分不能包含在括号里面。因为解析时会把括号里的所有东西视为一个整体，进而导致找不到解构模式而报语法错误。
   for......of  语句：也是可以用来给map结构的数据解构
        
      
      

