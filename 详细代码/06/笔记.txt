解构赋值：


      1.左右两边结构必须一样
      2.右边必须是个东西(等号右边的值，要么转为对象以后不具备 Iterator 接口，要么本身就不具备 Iterator 接口)
      3.声明和赋值不能分开(必须在一句话里完成)



      let [a,b,c]=[12,5,8];
      let {a,b,c}={a: 12, b: 5, c: 8};

      4.数组不完全结构：等号左边的变量个数   不等于   等号右边数据的个数
           变量要么等于 undefined   要么等于   ([])  空数组
      5.解构赋值允许指定默认值：
          只有当一个数组成员严格等于undefined，默认值才会生效；
          如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值：
           function f() {
              console.log('aaa');
            }
          let [x = f()] = [1];  //此时x等于1。   进而 f()  就不会被执行；
      6.set数据结构 的结构    等号的左边  使用  数组 
      
      
  对象的结构赋值：变量必须与属性同名，才能取到正确的值（结构时的位置可以不对应）
        1.如果结构失败：那么值为undefined
        2.如果变量名与属性名不一致：属性名（他是对象结构时的 模式 不是变量 不保存值 ）和变量名（他保存值）都要写出来，此时变量名保存的就是变量值：
            这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）：
                let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
            也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者：
                let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
                // baz // "aaa"
                // foo // error: foo is not defined    foo只是匹配的模式  而不是   变量
        3.模式可以 被匹配多次：
                let obj = {
                      p: [
                        'Hello',
                        { y: 'World' }
                      ]
                };

                let { p, p: [x, { y }] } = obj;  // 此时    模式p   被匹配   两次
                x // "Hello"
                y // "World"
                p // ["Hello", {y: "World"}]
          4.注意，对象的解构赋值可以取到继承的属性。
          
          
      对象的解构也可以指定默认值：默认值生效的条件是，对象的属性值严格等于undefined
              var {x, y = 5} = {x: 1};
                  x // 1
                  y // 5
              由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。
              解构赋值允许等号左边的模式之中，不放置任何变量名。
              
   变量先声明后赋值时的解构：
            对于数组，不会报错：
                  var a, b;
                  [a, b] = [1, 2];
                  console.log(a); // 1
                  console.log(b); // 2
            但是对于对象来说就会报错：
                  let x;
                  {x} = {x: 1};// SyntaxError: syntax error
                  
                  解决办法：
                        let x;
                        ({x} = {x: 1});    //具体原因，参考：https://developer.mozilla.org/zh-                                             CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
      
      
      

