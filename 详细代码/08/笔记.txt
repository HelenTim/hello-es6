字符串
1.多了两个新方法
  startsWith
  endsWith

2.字符串模板
  字符串连接

  i.直接把东西塞到字符串里面      ${东西}
  ii.可以折行

it.kaikeba.com


1.es5里面js的字符全都是用  ASCII  表示，但是发现并不能表示所有字符，例如 汉字 等；所以新增使用  Unicode码  来表示 其余的字符。
  JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。
      js与Unicode：参考，https://www.ruanyifeng.com/blog/2014/12/unicode.html
      1.1   允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示,否则（位数超出4位）只会显示出多余的位数的数字；ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。
      1.2   JavaScript 共有 6 种方法可以表示一个字符：
            '\z' === 'z'  // true
            '\172' === 'z' // true   （8进制）
            '\x7A' === 'z' // true   （16进制）
            '\u007A' === 'z' // true （Unicode 表示方法：16进制算法）
            '\u{7A}' === 'z' // true （Unicode 表示方法：16进制算法）
      1.3 一个字符我们可以称为码点：一个码元或者两个码元  组成 一个码点。码元与码点(参考：《深入理解ES6翻译完整版》第22/23页)
          传统的for无法识别大于0xFFFF的码点（一个码元的码点），但是 for.....of  可以识别包含两个码元的码点（字符）：let text = String.fromCodePoint(0x20BB7) 这样就可以表示一个 两个码元  的码点。
      1.4 JSON.stringify()的改变：
           根据标准，JSON 数据必须是 UTF-8 编码。但是，现在的JSON.stringify()方法有可能返回不符合 UTF-8 标准的字符串。
           UTF-8 标准规定，0xD800到0xDFFF之间的码点，不能单独使用，必须配对使用。
           为了确保返回的是合法的 UTF-8 字符，ES2019 改变了JSON.stringify()的行为。如果遇到0xD800到0xDFFF之间的单个码点，或者不存在的配对形式，它会返回转义字符串，留给应用自己决定下一步的处理。
      1.5 模板字符串：模板字符串（template string）是增强版的字符串，用反引号（`）标识
          它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。
          如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。也可以使用trim方法消除它门。
          模板字符串中嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。
          如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。
          模板字符串甚至还能嵌套。
      1.6 模板编译：字符串模板  通过正则  编译为具体字符串。
      1.7 标签模板：它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。（有名： 标签函数）
          第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分；
          其他参数，都是模板字符串各个变量被替换后的值；
          自注：${}两边会把字符串分割，如果哪一边没有其他字符串，那么分割出来的就是  空字符串  ———— ''；
          模板处理函数的第一个参数（模板字符串数组），还有一个raw属性：保存的是转义后（就连斜杠也会被转义）的原字符串。
      1.8 模板字符串的限制（自注：这是只用在1.7的知识点里，对于其他的字符串模板不适用。）（自注：这里我们可以把【函数名】当做一个标签）
          如果遇到不合法的字符串（例如：转义字符  后面又不是正常的东西 ）转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。
     
     
2.字符串新增方法：
      1.1  String.fromCodepoint:用于从 Unicode 码点返回对应字符     ————-——    codePointAt()：与前面相反
           与es5方法对比：String.fromCharCode():这个方法不能识别码点大于0xFFFF的字符   ————————    charCodeAt
           如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回：String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y' // true
      1.2  String.raw():该方法返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，往往用于模板字符串的处理方法。
           它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。
           String.raw()本质上是一个正常的函数，只是专用于模板字符串的标签函数。如果写成正常函数的形式，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组，对应模板字符串解析后的值：String.raw({ raw: ['foo', 'bar'] }, 1 + 2) // "foo3bar"；String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。
      1.3  如果我们要遍历  既包含2个字节的字符也包含4个字节的字符  的字符串：
           使用 for.....of:因为它会正确识别 32 位的 UTF-16 字符。
           另一种方法也可以，使用扩展运算符（...）进行展开运算。
           codePointAt()方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。
      1.4  实例方法：normalize()
           ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。
           normalize方法可以接受一个参数来指定normalize的方式。
           normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。
      1.5  实例方法：includes()，startsWith(), endswith()
           有第二个参数：使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。
      1.6  实例方法：repeat():repeat方法返回一个新字符串，表示将原字符串重复n次。
            参数如果是小数，会向下被取整。
            如果repeat的参数是负数或者Infinity，会报错。
            但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。
            参数NaN等同于 0。
            如果repeat的参数是字符串，则会先转换成数字。
      1.7   实例方法：padstart(), padEnd():第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。
            如果原字符串的长度，等于或大于最大长度，则字符串补全不生效，返回原字符串。
            如果用来补全的字符串与原字符串，两者的长度之和超过了最大长度，则会截去超出位数的补全字符串。
            如果省略第二个参数，默认使用空格补全长度。
      1.8   实例方法：trim start()， trimEnd()
            trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。
            浏览器还部署了额外的两个方法，trimLeft()是trimStart()的别名，trimRight()是trimEnd()的别名。
            
            
          




