# 1. RegExp构造函数
* ES5 不允许此时使用第二个参数添加修饰符，否则会报错。ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。    
```aidl
new RegExp(/abc/ig, 'i')  // 这里的ig修饰符会被覆盖
// 等价于 
var regex = /xyz/i;
```
     
# 2. 字符串的正则方法
* 字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。
ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。

# 3. u修饰符
* ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。
* 加了u修饰符以后，ES6 就会把大于\uFFFF的 Unicode 字符识别其为一个字符。
## 点字符
* 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。
** Unicode 字符表示法：ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。
## 自注： 只有加上 u修饰符 正则才能正确识别码点大于0xFFFF的 Unicode 字符
## 转义： 没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\,）无效，而在u模式会报错。

# 4. RegExp.prototype.unicode属性
## 正则实例对象新增unicode属性，表示是否设置了u修饰符。

# 5. y修饰符:除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。
* y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。
* 不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
* 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。
* y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。
* (RegExp.prototype.sticky属性)与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。
# 7. RegExp prototype. flags属性
* ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。
# 8. s修饰符：dotAll模式
* 正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符。
* 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。
* 有一种变通的写法。但解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。
* 正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。
* /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。
